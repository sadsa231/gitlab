# frozen_string_literal: true

module Gitlab
  module Page
    module Group
      module Settings
        module UsageQuotas
          # @note Defined as +link :seats_tab+
          # Clicks +seats_tab+
          def seats_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def seats_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_tab
          #   end
          # @return [Boolean] true if the +seats_tab+ element is present on the page
          def seats_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :seats_in_use+
          # @return [String] The text content or value of +seats_in_use+
          def seats_in_use
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_in_use_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def seats_in_use_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_in_use
          #   end
          # @return [Boolean] true if the +seats_in_use+ element is present on the page
          def seats_in_use?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +p :seats_used+
          # @return [String] The text content or value of +seats_used+
          def seats_used
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_used_element).to exist
          #   end
          # @return [Watir::P] The raw +P+ element
          def seats_used_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_used
          #   end
          # @return [Boolean] true if the +seats_used+ element is present on the page
          def seats_used?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +p :seats_owed+
          # @return [String] The text content or value of +seats_owed+
          def seats_owed
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_owed_element).to exist
          #   end
          # @return [Watir::P] The raw +P+ element
          def seats_owed_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_owed
          #   end
          # @return [Boolean] true if the +seats_owed+ element is present on the page
          def seats_owed?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +table :subscription_users+
          # @return [String] The text content or value of +subscription_users+
          def subscription_users
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.subscription_users_element).to exist
          #   end
          # @return [Watir::Table] The raw +Table+ element
          def subscription_users_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_subscription_users
          #   end
          # @return [Boolean] true if the +subscription_users+ element is present on the page
          def subscription_users?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +button :remove_user+
          # Clicks +remove_user+
          def remove_user
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.remove_user_element).to exist
          #   end
          # @return [Watir::Button] The raw +Button+ element
          def remove_user_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_remove_user
          #   end
          # @return [Boolean] true if the +remove_user+ element is present on the page
          def remove_user?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :pipelines_tab+
          # Clicks +pipelines_tab+
          def pipelines_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.pipelines_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def pipelines_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_pipelines_tab
          #   end
          # @return [Boolean] true if the +pipelines_tab+ element is present on the page
          def pipelines_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :buy_ci_minutes+
          # Clicks +buy_ci_minutes+
          def buy_ci_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.buy_ci_minutes_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def buy_ci_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_buy_ci_minutes
          #   end
          # @return [Boolean] true if the +buy_ci_minutes+ element is present on the page
          def buy_ci_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :plan_ci_minutes+
          # @return [String] The text content or value of +plan_ci_minutes+
          def plan_ci_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.plan_ci_minutes_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def plan_ci_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_plan_ci_minutes
          #   end
          # @return [Boolean] true if the +plan_ci_minutes+ element is present on the page
          def plan_ci_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :additional_ci_minutes+
          # @return [String] The text content or value of +additional_ci_minutes+
          def additional_ci_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.additional_ci_minutes_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def additional_ci_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_additional_ci_minutes
          #   end
          # @return [Boolean] true if the +additional_ci_minutes+ element is present on the page
          def additional_ci_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :ci_purchase_successful_alert+
          # @return [String] The text content or value of +ci_purchase_successful_alert+
          def ci_purchase_successful_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.ci_purchase_successful_alert_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def ci_purchase_successful_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_ci_purchase_successful_alert
          #   end
          # @return [Boolean] true if the +ci_purchase_successful_alert+ element is present on the page
          def ci_purchase_successful_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :storage_tab+
          # Clicks +storage_tab+
          def storage_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def storage_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_tab
          #   end
          # @return [Boolean] true if the +storage_tab+ element is present on the page
          def storage_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :purchase_more_storage+
          # Clicks +purchase_more_storage+
          def purchase_more_storage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.purchase_more_storage_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def purchase_more_storage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_purchase_more_storage
          #   end
          # @return [Boolean] true if the +purchase_more_storage+ element is present on the page
          def purchase_more_storage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :used_storage_message+
          # @return [String] The text content or value of +used_storage_message+
          def used_storage_message
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.used_storage_message_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def used_storage_message_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_used_storage_message
          #   end
          # @return [Boolean] true if the +used_storage_message+ element is present on the page
          def used_storage_message?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :group_usage_message+
          # @return [String] The text content or value of +group_usage_message+
          def group_usage_message
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.group_usage_message_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def group_usage_message_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_group_usage_message
          #   end
          # @return [Boolean] true if the +group_usage_message+ element is present on the page
          def group_usage_message?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :dependency_proxy_usage+
          # @return [String] The text content or value of +dependency_proxy_usage+
          def dependency_proxy_usage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.dependency_proxy_usage_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def dependency_proxy_usage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_dependency_proxy_usage
          #   end
          # @return [Boolean] true if the +dependency_proxy_usage+ element is present on the page
          def dependency_proxy_usage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :dependency_proxy_size+
          # @return [String] The text content or value of +dependency_proxy_size+
          def dependency_proxy_size
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.dependency_proxy_size_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def dependency_proxy_size_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_dependency_proxy_size
          #   end
          # @return [Boolean] true if the +dependency_proxy_size+ element is present on the page
          def dependency_proxy_size?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :container_registry_usage+
          # @return [String] The text content or value of +container_registry_usage+
          def container_registry_usage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.container_registry_usage_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def container_registry_usage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_container_registry_usage
          #   end
          # @return [Boolean] true if the +container_registry_usage+ element is present on the page
          def container_registry_usage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :project_storage_used+
          # @return [String] The text content or value of +project_storage_used+
          def project_storage_used
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.project_storage_used_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def project_storage_used_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_project_storage_used
          #   end
          # @return [Boolean] true if the +project_storage_used+ element is present on the page
          def project_storage_used?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :project+
          # @return [String] The text content or value of +project+
          def project
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.project_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def project_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_project
          #   end
          # @return [Boolean] true if the +project+ element is present on the page
          def project?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :storage_type_legend+
          # @return [String] The text content or value of +storage_type_legend+
          def storage_type_legend
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_type_legend_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def storage_type_legend_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_type_legend
          #   end
          # @return [Boolean] true if the +storage_type_legend+ element is present on the page
          def storage_type_legend?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :container_registry_size+
          # @return [String] The text content or value of +container_registry_size+
          def container_registry_size
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.container_registry_size_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def container_registry_size_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_container_registry_size
          #   end
          # @return [Boolean] true if the +container_registry_size+ element is present on the page
          def container_registry_size?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :purchased_usage_total_free+
          # @return [String] The text content or value of +purchased_usage_total_free+
          def purchased_usage_total_free
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.purchased_usage_total_free_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def purchased_usage_total_free_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_purchased_usage_total_free
          #   end
          # @return [Boolean] true if the +purchased_usage_total_free+ element is present on the page
          def purchased_usage_total_free?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :purchased_usage_total+
          # @return [String] The text content or value of +purchased_usage_total+
          def purchased_usage_total
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.purchased_usage_total_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def purchased_usage_total_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_purchased_usage_total
          #   end
          # @return [Boolean] true if the +purchased_usage_total+ element is present on the page
          def purchased_usage_total?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :storage_purchase_successful_alert+
          # @return [String] The text content or value of +storage_purchase_successful_alert+
          def storage_purchase_successful_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_purchase_successful_alert_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def storage_purchase_successful_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_purchase_successful_alert
          #   end
          # @return [Boolean] true if the +storage_purchase_successful_alert+ element is present on the page
          def storage_purchase_successful_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +h2 :storage_available_alert+
          # @return [String] The text content or value of +storage_available_alert+
          def storage_available_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_available_alert_element).to exist
          #   end
          # @return [Watir::H2] The raw +H2+ element
          def storage_available_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_available_alert
          #   end
          # @return [Boolean] true if the +storage_available_alert+ element is present on the page
          def storage_available_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end
        end
      end
    end
  end
end
